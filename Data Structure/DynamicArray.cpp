#include "DynamicArray.h"
using namespace std;

//Получить текущую длину массива
int DynamicArray::GetLength() {
    return _length;
}

//Получить текущую вместитеьность массива
int DynamicArray::GetCapacity() {
    return _capacity;
}

//Получить массив
int* DynamicArray::GetArray() {
    return _currentArray;
}

//Констуктор по умолчанию
DynamicArray::DynamicArray() : _capacity(4), _length(0),_growthFactor(2) {
    _currentArray = new int[_capacity](); 
}

//Изменяет размер массива, создавая новый массив
void  DynamicArray::ResizeArray()
{
    if (_length == _capacity)
    {
        CreateNewArray(_capacity * _growthFactor);
    }
    else if ((_length < _capacity / _growthFactor) && (_capacity  != MinCapacity))
    {
        CreateNewArray(_capacity / _growthFactor);

    }
}

//Создает новый массива с новой вместимостью. 
//Переуказывает указатель на новый созданный массив.
void DynamicArray::CreateNewArray(int capacity) 
{
    int* newArray = new int[capacity];
    for (int i = 0; i < _length; i++) {
        newArray[i] = _currentArray[i];
    }
    _capacity = capacity;
    delete[] _currentArray;
    _currentArray = newArray;
}

// Функция добавления элемента в конец массива
void DynamicArray::AddElement( int newElement)
{
    
    ResizeArray();
    _currentArray[_length] = newElement;
    _length++;
    ResizeArray();

}

// Функция вставки элемента вначало
void DynamicArray::AddElmentStart(int newElement)
{
    ResizeArray();
    for (int i = _length; i > 0; i--)
    {
        _currentArray[i] = _currentArray[i - 1];
    }
    _currentArray[0] = newElement;
    _length++;
    ResizeArray();
}

// Функция вставки элемента по индексу
void DynamicArray::Insert( int newElement, int indexOfElement)
{
    if (indexOfElement<=_length && indexOfElement >= 0) {
        ResizeArray();
        _length++;

        for (int i = _length - 1; i > indexOfElement; i--)
        {

            _currentArray[i] = _currentArray[i - 1];
        }
        _currentArray[indexOfElement] = newElement;
        ResizeArray();
    }

}

//Функция удаления элемента по индексу
void DynamicArray::DeleteElementIndex( int indexOfElement)
{

    if (indexOfElement < _length && indexOfElement>=0) {

        for (int i = indexOfElement; i <= _length - 1; i++)
        {
            if (_currentArray[i] == _currentArray[_length - 1])
            {
                break;
            }
            _currentArray[i] = _currentArray[i + 1];
        }
        _length--;
        ResizeArray();
    }
}

//Функция удаления элемента по значению
void DynamicArray::DeleteElementValue( int DeletedElement)
{
    int indexOfElement=-1;
    for (int i = 0; i < _capacity; i++)
    {
        if (_currentArray[i] == DeletedElement)
        {
            indexOfElement = i;
            break;
        }
    }
    if (indexOfElement !=-1 && _length!=0) {
        for (int i = indexOfElement; i <= _length - 1; i++)
        {
            if (_currentArray[i] == _currentArray[_length - 1])
            {

                break;
            }
            _currentArray[i] = _currentArray[i + 1];

        }
        _length--;
        ResizeArray();
    }
}

// Функция линейного поиска элемента в массиве
int DynamicArray::LinearSearch( int seacrhingElement)
{

    for (int i = 0; i < _length; i++)
    {
        if (_currentArray[i] == seacrhingElement)
        {
            return i;
            break;
        }
    }
    return -1;
}

//Функция объединения массивов
void DynamicArray::Merge( int left, int mid, int right)
{
    int n1 = mid - left + 1;
    int n2 = right - mid;

    // Создаем временные массивы
    int* L = new int[n1];
    int* R = new int[n2];

    // Копируем данные во временные массивы L[] и R[]
    for (int i = 0; i < n1; i++)
        L[i] = _currentArray[left + i];
    for (int j = 0; j < n2; j++)
        R[j] = _currentArray[mid + 1 + j];

    // Сливаем временные массивы обратно в array[left..right]
    int i = 0;    
    int j = 0;    
    int k = left; 

    while (i < n1 && j < n2)
    {
        if (L[i] <= R[j])
        {
            _currentArray[k] = L[i];
            i++;
        }
        else
        {
            _currentArray[k] = R[j];
            j++;
        }
        k++;
    }

    // Копируем оставшиеся элементы L[], если есть
    while (i < n1)
    {
        _currentArray[k] = L[i];
        i++;
        k++;
    }

    // Копируем оставшиеся элементы R[], если есть
    while (j < n2)
    {
        _currentArray[k] = R[j];
        j++;
        k++;
    }

    // Освобождаем память
    delete[] L;
    delete[] R;
}

//Вспомогательная функция для сортировки массива.
void DynamicArray::MergeSortHelper( int left, int right)
{
    if (left < right)
    {
        // Находим середину массива
        int mid = left + (right - left) / 2;

        // Рекурсивно сортируем две половины
        DynamicArray::MergeSortHelper( left, mid);
        DynamicArray::MergeSortHelper( mid + 1, right);

        // Сливаем отсортированные половины
        DynamicArray::Merge( left, mid, right);
    }
}

//Сортировка массива с помощью MergeSort
void DynamicArray::MergeSort()
{
    // Вызов вспомогательной функции с нулевыми индексами
    DynamicArray::MergeSortHelper( 0, _length - 1);
}

//Функция бинарного поиска
int DynamicArray::BinarySearch( int target) {
  
    DynamicArray::MergeSort();

    // Выполняем бинарный поиск
    int left = 0;
    int right = _length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (_currentArray[mid] == target) {
            
            return mid; 
        }
        if (_currentArray[mid] < target) {
            left = mid + 1;
        }
        else {
            right = mid - 1;
        }
    }
    return -1; 
}
